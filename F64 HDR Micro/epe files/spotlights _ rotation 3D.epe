{
  "name": "spotlights / rotation 3D",
  "id": "Fvhhj7uo6xaDciS46",
  "sources": {
    "main": "/*\n  Spotlights / rotation 3D\n  \n  This pattern demonstrates one way to rotationally transform 3D space, which\n  results in the impression we're rotating whatever pattern was generated.\n  \n  3D example: https://youtu.be/uoAJg5J6F1Q\n  \n  This pattern assumes a 3D installation that's been mapped in the Mapper tab,\n  but degrades to somewhat less interesting projections in 2D and 1D. \n*/\n\n\nscale = 1 / (PI * PI) // How wide the \"spotlights\" are\nspeed = 1             // How fast they rotate around\n\nexport function beforeRender(delta) {\n  // We could just use sin(time()) to output -1..1, but that's almost too smooth\n  t1 = 2 * triangle(time(.03 / speed)) - 1\n  t2 = 2 * triangle(time(.04 / speed)) - 1\n  t3 = 2 * triangle(time(.05 / speed)) - 1\n  t4 = time(.02 / speed)\n  \n  // The axis we'll rotate around is a vector (t1, t2, t3) - each -1..1.\n  // The angle to rotate about it is a 0..2*PI sawtooth.\n  setupRotationMatrix(t1, t2, t3, t4 * PI2)\n}\n\nexport function render3D(index, _x, _y, _z) {\n  // Shift (0, 0, 0) to be the center of the world, not the rear-top-left\n  x = _x - 0.5; y = _y - 0.5; z = _z - 0.5\n  \n  /*\n    In beforeRender(), setupRotationMatrix() calculated a rotation matrix for\n    this frame. rotate3D() now applies it to the current pixel's [shifted]\n    position. As seen below, this sets rotated global variables rx, ry, and rz.\n    You could also return an array of [rx, ry, rz], but that adds one slightly\n    slower step to an already computationally-intense pattern.\n  */\n  rotate3D(x, y, z)\n  \n  /*\n    `dist` is the distance (in world units) from a cone's surface to this \n    pixel. Positive values are inside the cone. If you try a different scale\n    for x vs y, you'll see elliptical cones.\n  */\n  dist = abs(rz) - sqrt(rx * rx / scale + ry * ry / scale)\n\n  dist = clamp(dist, -1, 1) // Try commenting this out.. Whoa!\n  \n  //  magenta,  white center,  sub-pixel rendered border\n  hsv(0.97,     1-dist,        pow((1 + dist), 4))\n}\n\n// A planar slice of this pattern will look like a projection surface that\n// someone's waving a flashlight at.\nexport function render2D(index, x, y) {\n  render3D(index, x, y, 0)\n}\n\n// In 1D it's a frenetic swooping region\nexport function render(index) {\n  render3D(index, index / pixelCount * 2, 0, 0)\n}\n  \n\n\n/*\n  setupRotationMatrix()\n  Takes a vector (ux, uy, uz) which will be the axis to rotate around,\n    and an angle in radians.\n  Computes a 3D rotation matrix and stores it in a global named R\n  \n  https://en.wikipedia.org/wiki/Rotation_matrix\n*/\n\nvar R = array(3); for (i=0; i<3; i++) R[i] = array(3)  // init 3x3, R[r][c]\n\nfunction setupRotationMatrix(ux, uy, uz, angle) {\n  // Rescale ux, uy, uz to make sure it's a unit vector, length = 1\n  length = sqrt(ux * ux + uy * uy + uz * uz)\n  ux /= length; uy /=length; uz /= length\n  \n  // Precompute a few reused values\n  cosa = cos(angle); sina = sin(angle)\n  ccosa = 1 - cosa\n  xyccosa = ux * uy * ccosa\n  xzccosa = ux * uz * ccosa\n  yzccosa = uy * uz * ccosa\n  xsina = ux * sina; ysina = uy * sina; zsina = uz * sina\n  \n  R[0][0] = cosa + ux * ux * ccosa\n  R[0][1] = xyccosa - zsina\n  R[0][2] = xzccosa + ysina\n  R[1][0] = xyccosa + zsina\n  R[1][1] = cosa + uy * uy * ccosa\n  R[1][2] = yzccosa - xsina\n  R[2][0] = xzccosa - ysina\n  R[2][1] = yzccosa + xsina\n  R[2][2] = cosa + uz * uz * ccosa\n}\n\n/*\n  rotate3D()\n  Takes 3 coordinates (x, y, z) and expects R to be a global rotation matrix.\n  Sets globals rx, ry, and rz as the rotated point's new coordinates.\n  (Globals are used for speed and convenience in the Pixelblaze lang)\n*/\nvar rx, ry, rz\nfunction rotate3D(x, y, z) {\n  rx = R[0][0] * x + R[0][1] * y + R[0][2] * z\n  ry = R[1][0] * x + R[1][1] * y + R[1][2] * z\n  rz = R[2][0] * x + R[2][1] * y + R[2][2] * z\n}\n"
  },
  "preview": "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"
}