{
  "name": "fractal flower",
  "id": "muG3ExCnFkcF6SF3g",
  "sources": {
    "main": "/*\nFractal Flower\n2021 Ben Hencke\n*/\n\n//*********** Settings ***********/\n//set up the source matrix dimensions - match to your display for best results\n//or set lower for a pixelated mosaic\nvar width = 8\nvar height = 8\n\n//globals for dynamic settings\n//*********** Settings ***********/\n\nexport var iterations = 5\nexport var drawLevels = 4 //skip drawing some starting iterations\n\nexport var scale = .035\nexport var speed = 7\nexport var fade = .9\n\nexport var angleRange1 = 1\nexport var angleRange2 = 1\n\nexport var replicas = 5\nexport var spacing = .2\n\nexport var useWhite = true\nexport var usePinwheel = true\nexport var wrapWorld = false\n\n\n//globals for calculations\n//*********** Settings ***********/\nvar pixels = array(width * height)\nvar hues = array(width * height)\nvar color, branchAngle1, branchAngle2, h, v\n\n//*********** Globals for watching ***********/\nexport var iter //see how many iterations are run\nexport var maxValue //the brightest pixel\nexport var valueFactor = 20 //used to adjust brightness automatically\n\n//*********** UI Controls ***********/\nexport function sliderIterations(v) {iterations = 1 + floor(v*8)}\nexport function sliderDrawLevels(v) {drawLevels = 1 + floor(v*8)}\nexport function sliderScale(v) {scale = v * v * .1}\nexport function sliderSpeed(v) {speed = 1 + ceil(v * 10) * 3}\nexport function sliderAngleRange1(v) {angleRange1 = v * 2}\nexport function sliderAngleRange2(v) {angleRange2 = v * 2}\nexport function sliderTrails(v) {fade = v && (v * .5 + .5)}\nexport function sliderReplicas(v) {replicas = 1 + floor(v*12)}\nexport function sliderSpacing(v) {spacing = v/2}\nexport function sliderWhiteMode(v) {useWhite = v > .5}\nexport function sliderPinwheelMode(v) {usePinwheel = v > .5}\nexport function sliderWrapMode(v) {wrapWorld = v > .5}\n\n//*********** Utility Functions ***********/\n//map an x and y into a 1D array\nfunction getIndex(x, y) {\n  var res = floor(x*width) + floor(y*height)*width\n  return res\n}\n\nfunction blendHue(h1, v1, h2, v2) {\n  v = v1+v2\n  //rotate hues so that they are closer numerically\n  if (h2 - h1 > .5)\n    h2 -= 1\n  if (h1 - h2 > .5)\n    h1 -= 1\n  //average the hues, weighted by brightness\n  h = (h1 * v1 + h2 * v2) / v\n}\n\n//*********** Fractal Implementation ***********/\nfunction fractal(x, y, a, i) {\n  var index, l\n  \n  \n  iter++ //keep track of how many calls we've made\n\n  //move coordinates in direction vector for our angle\n  \n  //each iteration travels a smaller distance\n  //but don't travel for the first iteration\n  if (i < iterations)  {\n    l = i * scale + scale\n    x += sin(a) * l;\n    y += cos(a) * l;\n  }\n\n  //make coordinates \"wrap\" around to the other side\n  if (wrapWorld) {\n    x = mod(x,.99999)\n    y = mod(y,.99999)\n  }\n  \n  //skip earlier levels, and only draw \"on screen\"\n  if(i <= drawLevels && x >= 0 && x <= .99999 && y >= 0 && y <= .999999) {\n    index = getIndex(x,y)\n    \n    // blendHue(hues[index], pixels[index], iter * .004 + color , hues[index] + 1)\n    blendHue(hues[index], pixels[index], i * .1 + color, 1)\n    \n    hues[index] = h\n    pixels[index] = v\n  }\n  \n  if (--i > 0) {\n    //if there are more iterations left, recurse to this function adding rotations for each branch\n    fractal(x, y, a + branchAngle1, i)\n    fractal(x, y, a + branchAngle2, i)\n  }\n}\n\n//*********** Rendering ***********/\n\nexport function beforeRender(delta) {\n  var startingAngle, i\n  \n  //update globals used by the fractal\n  color = time(1 / speed)\n  branchAngle1 = -1 + sin(wave(time(4.4 / speed))*PI2) * PI * angleRange1\n  branchAngle2 = .5 + sin(wave(-time(11 / speed))*PI2) * PI * angleRange2\n\n  startingAngle = sin(time(3 / speed) * PI2) * PI\n  \n  //fade out pixel values\n  pixels.mutate(p => p*fade)\n  \n  iter = 0\n  if (replicas > 1) {\n    for (i = 0; i < replicas; i++) {\n      if (usePinwheel) {\n        //pinwheel - rotate petal in place\n        fractal(0.5 + spacing * sin(i/replicas * PI2), 0.5 + spacing * cos(i/replicas * PI2), startingAngle + i/replicas * PI2, iterations)\n      } else {\n        //roate petals around center\n        fractal(0.5 + spacing * sin(i/replicas * PI2 + startingAngle), 0.5 + spacing * cos(i/replicas * PI2 + startingAngle), 0*startingAngle + i/replicas * PI2, iterations)\n      }\n    }\n  } else {\n    //for a single fractal instance, ignore spacing and draw in center.\n    fractal(.5,.5, startingAngle, iterations)\n  }\n  \n  //adjust valueFactor to scale brightness based on the last maxValue found in the previous render\n  //this helps bring out more detail when many fractal dots overlap\n  //do this gradially over time to avoid flickering\n  valueFactor = clamp(valueFactor*.95 + maxValue*.05, 1, 100)\n  maxValue = 0\n  \n  // resetTransform()\n  // translate(-.5, -.5)\n  // rotate(wave(time(.2)) * PI*2)\n  // translate(.5, .5)\n}\n\nexport function render2D(index, x, y) {\n  var vc = 0\n  index = getIndex(x, y) //figure out index from coordinate\n  if (index >= pixels.length || index < 0) return\n  v = pixels[index]\n  maxValue = max(maxValue, v) //keep track of the brightest pixel\n  v = v / valueFactor //scale brightness down\n  v = v*v //give things a bit more contrast\n  if (useWhite)\n    s = 1.5 - v //highlight bright pixels by shifting toward white\n  else\n    s = 1\n  hsv(hues[index], s, v)\n}\n"
  },
  "preview": "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"
}