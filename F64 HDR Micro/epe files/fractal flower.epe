{
  "name": "fractal flower",
  "id": "muG3ExCnFkcF6SF3g",
  "sources": {
    "main": "/*\nFractal Flower\n2021 Ben Hencke\n*/\n\n//*********** Settings ***********/\n//set up the source matrix dimensions - match to your display for best results\n//or set lower for a pixelated mosaic\nvar width = 8\nvar height = 8\n\n//globals for dynamic settings\n//*********** Settings ***********/\n\nexport var iterations = 5\nexport var drawLevels = 4 //skip drawing some starting iterations\n\nexport var scale = .035\nexport var speed = 7\nexport var fade = .9\n\nexport var angleRange1 = 1\nexport var angleRange2 = 1\n\nexport var replicas = 5\nexport var spacing = .2\n\nexport var useWhite = true\nexport var usePinwheel = true\nexport var wrapWorld = false\n\n\n//globals for calculations\n//*********** Settings ***********/\nvar pixels = array(width * height)\nvar hues = array(width * height)\nvar color, branchAngle1, branchAngle2, h, v\n\n//*********** Globals for watching ***********/\nexport var iter //see how many iterations are run\nexport var maxValue //the brightest pixel\nexport var valueFactor = 20 //used to adjust brightness automatically\n\n//*********** UI Controls ***********/\nexport function sliderIterations(v) {iterations = 1 + floor(v*8)}\nexport function sliderDrawLevels(v) {drawLevels = 1 + floor(v*8)}\nexport function sliderScale(v) {scale = v * v * .1}\nexport function sliderSpeed(v) {speed = 1 + ceil(v * 10) * 3}\nexport function sliderAngleRange1(v) {angleRange1 = v * 2}\nexport function sliderAngleRange2(v) {angleRange2 = v * 2}\nexport function sliderTrails(v) {fade = v && (v * .5 + .5)}\nexport function sliderReplicas(v) {replicas = 1 + floor(v*12)}\nexport function sliderSpacing(v) {spacing = v/2}\nexport function sliderWhiteMode(v) {useWhite = v > .5}\nexport function sliderPinwheelMode(v) {usePinwheel = v > .5}\nexport function sliderWrapMode(v) {wrapWorld = v > .5}\n\n//*********** Utility Functions ***********/\n//map an x and y into a 1D array\nfunction getIndex(x, y) {\n  var res = floor(x*width) + floor(y*height)*width\n  return res\n}\n\nfunction blendHue(h1, v1, h2, v2) {\n  v = v1+v2\n  //rotate hues so that they are closer numerically\n  if (h2 - h1 > .5)\n    h2 -= 1\n  if (h1 - h2 > .5)\n    h1 -= 1\n  //average the hues, weighted by brightness\n  h = (h1 * v1 + h2 * v2) / v\n}\n\n//*********** Fractal Implementation ***********/\nfunction fractal(x, y, a, i) {\n  var index, l\n  \n  \n  iter++ //keep track of how many calls we've made\n\n  //move coordinates in direction vector for our angle\n  \n  //each iteration travels a smaller distance\n  //but don't travel for the first iteration\n  if (i < iterations)  {\n    l = i * scale + scale\n    x += sin(a) * l;\n    y += cos(a) * l;\n  }\n\n  //make coordinates \"wrap\" around to the other side\n  if (wrapWorld) {\n    x = mod(x,.99999)\n    y = mod(y,.99999)\n  }\n  \n  //skip earlier levels, and only draw \"on screen\"\n  if(i <= drawLevels && x >= 0 && x <= .99999 && y >= 0 && y <= .999999) {\n    index = getIndex(x,y)\n    \n    // blendHue(hues[index], pixels[index], iter * .004 + color , hues[index] + 1)\n    blendHue(hues[index], pixels[index], i * .1 + color, 1)\n    \n    hues[index] = h\n    pixels[index] = v\n  }\n  \n  if (--i > 0) {\n    //if there are more iterations left, recurse to this function adding rotations for each branch\n    fractal(x, y, a + branchAngle1, i)\n    fractal(x, y, a + branchAngle2, i)\n  }\n}\n\n//*********** Rendering ***********/\n\nexport function beforeRender(delta) {\n  var startingAngle, i\n  \n  //update globals used by the fractal\n  color = time(1 / speed)\n  branchAngle1 = -1 + sin(wave(time(4.4 / speed))*PI2) * PI * angleRange1\n  branchAngle2 = .5 + sin(wave(-time(11 / speed))*PI2) * PI * angleRange2\n\n  startingAngle = sin(time(3 / speed) * PI2) * PI\n  \n  //fade out pixel values\n  pixels.mutate(p => p*fade)\n  \n  iter = 0\n  if (replicas > 1) {\n    for (i = 0; i < replicas; i++) {\n      if (usePinwheel) {\n        //pinwheel - rotate petal in place\n        fractal(0.5 + spacing * sin(i/replicas * PI2), 0.5 + spacing * cos(i/replicas * PI2), startingAngle + i/replicas * PI2, iterations)\n      } else {\n        //roate petals around center\n        fractal(0.5 + spacing * sin(i/replicas * PI2 + startingAngle), 0.5 + spacing * cos(i/replicas * PI2 + startingAngle), 0*startingAngle + i/replicas * PI2, iterations)\n      }\n    }\n  } else {\n    //for a single fractal instance, ignore spacing and draw in center.\n    fractal(.5,.5, startingAngle, iterations)\n  }\n  \n  //adjust valueFactor to scale brightness based on the last maxValue found in the previous render\n  //this helps bring out more detail when many fractal dots overlap\n  //do this gradially over time to avoid flickering\n  valueFactor = clamp(valueFactor*.95 + maxValue*.05, 1, 100)\n  maxValue = 0\n  \n  // resetTransform()\n  // translate(-.5, -.5)\n  // rotate(wave(time(.2)) * PI*2)\n  // translate(.5, .5)\n}\n\nexport function render2D(index, x, y) {\n  var vc = 0\n  index = getIndex(x, y) //figure out index from coordinate\n  if (index >= pixels.length || index < 0) return\n  v = pixels[index]\n  maxValue = max(maxValue, v) //keep track of the brightest pixel\n  v = v / valueFactor //scale brightness down\n  v = v*v //give things a bit more contrast\n  if (useWhite)\n    s = 1.5 - v //highlight bright pixels by shifting toward white\n  else\n    s = 1\n  hsv(hues[index], s, v)\n}\n"
  },
  "preview": "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"
}