{
  "name": "infinity flower",
  "id": "4PkMa6vt2jwMdt2om",
  "sources": {
    "main": "/* Infinity Flower\n\n Creates a colorful new flower species every couple of seconds!\n \n Requires a 2D display and appropriate mapping function.\n\n MIT License\n \n Version  Author        Date      \n 1.0.0    JEM(ZRanger1) 05/07/2021\n*/ \nvar radius = array(pixelCount);   // holds every pixel's distance from center\nvar angle = array(pixelCount);    // every pixel's positive radial angle from center\n\nvar lifespan = 1500;              // how long we display each flower\nvar transitionLength = 1000;       // how long the spin/generate phase lasts\nvar speciesTimer = 9999;          // accumulator for frame timing\n\nvar drawFrame = renderFirstPass;  // on first pass, calculate per-pixel stats\nvar prerender = beforeNormal;     // normal renderer\n\nvar tolerance;                    // comparison tolerance for angles\n\nvar maxPetals = 12;               // this seems like plenty...\nvar numPetals;                    // petals in current species\nvar petalShape;                   // rough width of petal\nvar petalLength;                  // radius of each petal   \nvar centerHue;                    // color of flower center\nvar centerSize;                   // radius of flower center\nvar centerBri;                    // max brightness of flower center\nvar colorVariant;                 // enables additional petal coloring\nvar petals = array(maxPetals);    // holds information on each petal\nvar p1 = array(2);                // scratch x,y point array for calculation\n\n// allocate space for petal information. Fields are, in order:\n// x,y,angle,hue.  \nfunction allocate() {\n  for (i = 0; i < maxPetals;i++) {\n    petals[i] = array(4);\n  }\n}\n\n// Create a new flower species with (constrained) randomized parameters.\nfunction initialize() {\n  numPetals = max(2,floor(random(maxPetals)));\n  petalLength = 0.35 + random(0.3);\n  petalShape = 3+random(4);\n  petalHue = random(1);\n  centerHue = petalHue + 0.61803;  // golden ratio conjugate makes good contrasting colors\n  centerSize = (random(1) < 0.7) ? 0.11 : 0.1;\n  colorVariant = random(1) > 0.5;\n  \n  var hueVariance = (0.1 * (-0.5 + random(1)))\n  var petalAngle = 2.39996;        // golden angle separates petals\n  \n  p1[0] = 0.5; p1[1] = petalLength + 0.5;\n\n  for (i = 0; i < numPetals;i++) {\n    petals[i][3] = petalHue + ((i % 2) * hueVariance);\n    \n    setRotationAngle(petalAngle);      \n    rotateVector2D(p1,petals[i]);\n    petals[i][2] = petalAngle;  \n    \n    petalAngle += 2.39996;\n  }  \n  \n  setRotationAngle(0);\n}\n\n// wrapper for atan2 that returns positive angle 0-PI2\nfunction positiveAtan2(x,y) {\n  var rad = atan2(x,y);\n  return (rad >= 0) ? rad : rad + PI2;\n}\n\n// set angle for subsequent 2D rotation calls\nfunction setRotationAngle(angle) {\n  cosT = cos(angle); sinT = sin(angle);\n}\n\nvar cosT = 0;  var sinT = 0;\nfunction rotateVector2D(vIn, vOut) {\n    var x = vIn[0] - 0.5;  var y = vIn[1] - 0.5;\n    vOut[0] = (cosT * x) - (sinT * y) + 0.5;\n    vOut[1] = (sinT * x) + (cosT * y) + 0.5;\n}\n\nfunction renderFirstPass(index,x,y) {\n  x -= 0.5; y -= 0.5;\n  radius[index] = hypot((x),(y));\n  angle[index] = positiveAtan2(x,y);\n  if (index == (pixelCount - 1)) drawFrame = renderNormal;\n}\n\n\nfunction renderNormal(index,x,y) {\n  var h,v,pWidth;\n\n// if pixel is outside max radius, nothing to do  \n  if (radius[index] > petalLength) {\n    rgb(0,0,0);\n    return;\n  }\n  \n// color and shade flower center pixels\n  if (radius[index] < centerSize) {\n    hsv(centerHue,1,centerBri * wave(-0.25+(radius[index]/centerSize*0.9)));\n    return;\n  }\n  \n  // determine for the width of petal at a given radius.\n  // angular comparison tolerance has to decrease with radius to compensate for\n  // fixed pixel pitch in display.  \n  tolerance = 0.06*(0.707/radius[index])\n  pWidth = tolerance * petalShape * (wave(-0.25+(radius[index]/petalLength)));\n\n// color pixel if it lies on a petal.\n  for (i = 0; i < numPetals; i++) {\n    v = PI-abs(PI - abs(angle[index] - petals[i][2]));    \n    v = (v <= pWidth) ? max(0.01,v) : 0;\n    if (v > 0) {\n      h = petals[i][3] + (colorVariant * radius[index] * 0.7);\n      break;\n    }\n  }\n\n  hsv(h, 1-(v*0.33), v) \n\n}\n\n// beforeRender() function that runs when we're building a new flower\nfunction beforeTransition(delta) {\n  speciesTimer += delta;\n  \n// when transition is done, stop spinning and switch back to the\n// normal display beforeRender function.\n  if (speciesTimer >= transitionLength) {\n    initialize();\n    speciesTimer = 0;\n    centerBri = 1;\n    prerender = beforeNormal;\n  }\n  \n  centerBri = 1-(speciesTimer / transitionLength);\n\n  for (i = 0; i < numPetals; i++) {\n    rotateVector2D(petals[i],petals[i]);   \n    petals[i][2] = positiveAtan2(petals[i][0]-0.5,petals[i][1]-0.5);\n  }  \n}\n\n// beforeRender() function that displays the current flower species.\nfunction beforeNormal(delta) {\n  speciesTimer += delta;\n  \n// when we're ready to build a new species, start the spinning effect\n// and set the beforeRender function to the transition \n// generator.\n  if (speciesTimer >= lifespan) {\n    prerender = beforeTransition;\n    setRotationAngle((random(1) < 50) ? 1 : -1);\n    speciesTimer = 0;\n  }\n}\n\n// main entry point\nallocate();\ninitialize();\n\n// system callbacks\nexport function beforeRender(delta) {\n  prerender(delta);\n}\n\nexport function render2D(index,x,y) {\n  drawFrame(index,x,y);\n}"
  },
  "preview": "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"
}