{
  "name": "Archaos",
  "id": "zqJhaSozbKX8HRDj5",
  "sources": {
    "main": "/*  Archaos\n  *\n  * Arc Cosine makes some regular polygons; Chaotically animates params\n  *\n  * See https://www.desmos.com/calculator/ufugbkkpek\n  *\n  * Jeff Vyduna / MIT License\n*/\n\n// Debug / dev utilities\n// export var _w1  = -1, _w2 = -1, _w3 = -1 // Watch variables; sort _ to top\n// export var _min, _max\n// trackMinMax= (v) => { _min = min(_min, v); _max = max(_max, v) }\n// export var _p1, _p2, _p3  // Development tuning params\n// export var sliderP1 = v => _p1 = v \n// export var sliderP2 = v => _p2 = v\n// export var sliderP3 = v => _p3 = v\n\n// Going for very subtle here\nexport var brightness = .2\nexport var sliderBrightness = v => brightness = v\n\nvar cycleProgress = 0\n// Uncomment this slider to manually scroll through the shapes\n// export function sliderCycleProgress(_v) {\n//   cycleProgress = clamp(_v, 0, 1 - .001)\n// }\n\n\n// Line width: 40 good for most with scale 4 and below\n// Width 2.8 best on F64 for scale 7 ?!? OK.\nvar width = 40 \n// export function sliderWidthInvK(_v) {\n//   width = (1 - _v) * 40\n// }\n\n// Line edge sharpness: 2.1 good for most\nvar sharpness = 2.1 \n// export function sliderSharpnessInvN(_v) {\n//   sharpness = (1 - _v) * 20\n// }\n\nvar userScaleFactor = 1\n// export function sliderScale(_v) {\n//   userScaleFactor = .25 + 1.5 * _v\n// }\n\nvar userRotation = 0\n// export function sliderRotation(_v) {\n//   userRotation = PI2 * _v\n// }\n\n\nvar cycles // Number of line segments of lines to compute. 4 to 20 is interesting.\nvar scaleFactor // The polygons generated are different sizes, so we scale to fit them to the F64 display\n//  [cycles, scale] pairs for the the selected regular polygons to linger near \nvar cycleStops = [[4, 4],    // Two lines\n                  [5, 7],    // Pentagram\n                  [6, 4],    // Triangle\n                  [7, 3.25], // Heptagram\n                  [8, 3],    // Square\n                  [20, 2.5], // Dual decagon but basically a circle\n                  [20, 2.5]] // Spend more time on this last one\n\nvar movementFrac // Percen of time spent trnasitioning between cycleStops\n\nvar lastRotationTarget, rotationTarget  // Radians \nvar rotationProgress = 1 // 0..1 ramp between lastRotationTarget and rotationTarget\nvar rotationDuration     // Full time to reach rotationTarget (not always rotating during this period)\nvar hue0\n\nexport function beforeRender(delta) {\n  resetTransform()\n  translate(-.5, -.5)         // Center at (0,0)\n  \n  progressRamp = time (90 / 65.536)\n  movementFrac = .5 + .2 * wave(time(20 / 65.535))\n  \n  colorT1 = smoothstep(wave(time(60 / 65.535)), .2, .8)\n  hue0 = .66 + (1-brightness)*.44 // Combat color temp cooling on low brightness\n  \n  setCyclesAndScale(cycleProgress ? cycleProgress : progressRamp)\n\n  scaleLFO = .9 + wave(time(30 / 65.5)) / 5\n  scaleFactor *=  scaleLFO * userScaleFactor\n  scale(scaleFactor, scaleFactor)\n  \n  doRotation(delta)\n}\n\nvar MRP = 16  // Mean Rotation Period in seconds (mean a binomial distribution)\nvar UDR = MRP * 2 / 4  // Uniform Distribution Range, for sum of 4 uniform distributions\nfunction doRotation(delta) {\n  if (rotationProgress >= 1) {\n    rotationProgress = 0\n    rotationDuration = [UDR, UDR, UDR, UDR].reduce((acc, v) => acc + random(v), 2) // Sample from binomial dist\n    lastRotationTarget = rotationTarget\n    rotationTarget = random(PI2) - PI\n  }\n  \n  rotationProgress += delta / rotationDuration / 1000\n  lastRotationTarget + (rotationTarget - lastRotationTarget) * smoothstep(rotationProgress, .5, .999)\n  rotate(userRotation + lastRotationTarget + (rotationTarget - lastRotationTarget) * smoothstep(rotationProgress, .5, .999))\n}\n\nexport var scaleFactor\n// For t1 in 0..2\n// Interpolate between pairs of [[cycles, scale], [nextCycles, nextScale]] in cycleStops\nfunction setCyclesAndScale(t1) {\n  var maxIndex = cycleStops.length - 1\n  var interpIndex = smoothstair(t1 * (maxIndex),  movementFrac)\n  var pct = 1 - frac(interpIndex)\n\n  var next = cycleStops[(interpIndex + 1) % (cycleStops.length - 1)] // Circular\n  cycles = cycleStops[interpIndex][0] * pct + next[0] * (1 - pct)\n  scaleFactor = cycleStops[interpIndex][1] * pct + next[1] * (1 - pct)\n  width = clamp((scaleFactor-4)*-37.2/3 + 40, 2.8, 40) // Experimementally determined [(4, 40), (7, 2.8)]\n}\n\n\nexport function render2D(index, x, y) {\n  var r =  hypot(x, y)\n  var phi = atan2(y, x) + 1.0 * PI // Reminder that output range of atan2 is in [-PI..PI]\n  renderPolar(index, r, phi)\n}\n\nexport function renderPolar(index, r, phi) {\n  // Distance between actual r and ideal computed r(phi), for domain phi in [0, 4*PI]\n  // This does distort the scalar field vs cartesian distance error\n  // hence why triangle/square sides look a little bit bent\n  var dist = 100\n  for (var revolution = 0; revolution < 2; revolution++) {\n    var denom = cos(2 / cycles * acos(cos(cycles / 2 * (phi + revolution * PI2))))\n    var revDist = denom < 0.01 ? 20 : abs(r - 1 / denom)\n    dist = min(dist, revDist)\n  }\n  \n  var v = expStep(dist, width, sharpness)\n  \n  var colorGradient = clamp(1 + colorT1 - r/scaleFactor, 0, 1)\n  \n  hsv(hueGradient(colorGradient), satGradient(colorGradient), v * brightness)\n}\n\n\n\n// Takes 0..1, returns an  warm-white to an cool blue\n// hue0 defined in beforeRender() \nvar hue1 = 1.04\nfunction hueGradient(t) {\n  return hue0 + (hue1 - hue0) * t\n}\n\nvar sat0 = 0.5\nvar sat1 = .87\nfunction satGradient(t) {\n  return sat0 + t * (sat1 - sat0) * abs(.5 - t)/.5\n}\n\n\n// https://iquilezles.org/articles/functions/\n// https://www.desmos.com/calculator/b0seqywous\nfunction expStep(x, k, n) {\n  var result = exp(-k * pow(x, n))\n  return (result > 1) ? 0 : result\n}\n\n// https://thebookofshaders.com/glossary/?search=smoothstep\n// https://www.desmos.com/calculator/as0c0vjjum\nfunction smoothstep(x, edge0, edge1) {\n  var t = clamp((x - edge0) / (edge1 - edge0), 0, 1);\n  return t * t * (3 - 2 * t)\n}\n\n// https://www.desmos.com/calculator/npueouzdvc\nfunction smoothstair(x, transitionFrac) {\n  return floor(x) + smoothstep(frac(x), .9999 - transitionFrac, .9999)  \n}\n\n\n"
  },
  "preview": "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"
}