{
  "name": "Cyclic Cellular Automata 2D",
  "id": "bBNp6TkDjRCfvN3sB",
  "sources": {
    "main": "/* Cyclic Cellular Automata 2D\n\n Displays a cyclic cellular automaton, and a variant of the Greenberg-Hastings CCA: \n \n https://en.wikipedia.org/wiki/Greenberg%E2%80%93Hastings_cellular_automaton\n \n This flavor of CA is used to model \"excitable\" systems -- a system that can \n activate, and support the passage of a wave of some sort, after which it\n must \"rest\" for some period of time before another wave can pass.  \n \n A forest fire is the canonical example of this kind of system...\n \n Requires a 2D LED array and appropriate pixel mapper.\n \n UI Sliders: \n Speed:      Controls number of milliseconds per frame\n Lifetime:   How long a given pattern runs before being re-randomized\n             A lifetime of 0 means \"forever\"\n Threshold:  Number of correctly valued neighbors required to advance to\n             the next state.\n States:     Number of allowed states for each cell.              \n Excited:    Percentage of cells to initialize to the excited state\n Refractory: Percentage of cells to initialize to a random refractory level\n Mode:       Switches between Greenberg-Hastings and \"normal\" cyclic CA.  Flipping\n             the mode switch restores default values for the more sensitive\n             parameters.\n \n Cells are randomly initialized according to the current mode and parameter set.\n Some initial condition sets may \"fizzle\" and die out.  If this occurs, the \n pattern will automatically re-initialize.\n \n The default settings produce mostly \"good\" results, but this pattern rewards\n experimentation and a bit of patient watching.  It can produce beautiful visuals\n that would be near impossible to make any other way!\n\n MIT License\n \n Version  Author        Date      \n 1.0.0    JEM(ZRanger1) 05/03/2021\n*/ \n\n// display size - enter the dimensions of your matrix here\nvar width = 16;\nvar height = 16;\n\n\n// Global variables for rendering.  Buffers are purposely allocated\n// oversize so we have a bounding region that saves us from clipping\n// and wrapping issues.\nvar buffer1 = array(height);   // main drawing surface\nvar buffer2 = array(height);   // secondary drawing surface\nvar pb1, pb2;                  // buffer pointers for swapping\nexport var numStates = 24;\nexport var speed = 60;         // milliseconds per frame\nexport var lifetime = 10000;   // how long between reinitializations\nexport var excited = 0.03;     // % cells initialized to \"excited\" state\nexport var refractory = 0.64;  // % cells initialized to random refractory level\nexport var threshold = 1;      // minimum activation level\nvar mode = 0;                  // 0 = Greenberg-Hastings, 1 = Cyclic CA\nvar calcNextGen = doGenerationGH;\nvar nextVal = 1;\nvar frameTimer = 9999;         // accumulator for simulation timer\nvar patternTimer = 9999;       // accumulator for pattern lifetime\n\n// UI\nexport function sliderSpeed(v) {\n  speed = 1000 * v * v;\n}\n\n// lifetime of pattern in milliseconds.  0 == forever\nexport function sliderLifetime(v) {\n  lifetime = v * 30000;\n}\n\n// Set operating mode: 0 == GBH, 1 = CCA\nexport function sliderMode(v) {\n  mode = (v > 0.5);\n  \n  calcNextGen = mode ? doGenerationCCA : doGenerationGH;\n  \n  if (mode == 0) {\n    threshold = 1;\n    numStates = 24;\n    excited = 0.03;\n    refractory = 0.64;\n  }\n  else {\n    threshold = 3;\n    numStates = 3;\n  }\n}\n\n// Advanced UI Controls\n// Uncomment the block below if you want to play with more parameters.\n// Enabling these sliders breaks the Mode slider's automatic setting of \n// reasonable defaults for the more sensitive parameters, so if you like\n// your settings, take note of them before you do this.  And remember\n// \n// \"With great power comes great responsibility\" - Spider-man\n/*\nexport function sliderThreshold(v) {\n  threshold = 1+floor(v * 3);\n}\n\nexport function sliderStates(v) {\n  numStates = floor(v * 32);\n}\n\n// allows a maximum of 20% of cells to be initially excited\nexport function sliderExcited(v) {\n  excited = 0.20 * v * v;\n}\n\n// allows a maximum of 80% of cells to be initialied to the\n// refractory state\nexport function sliderRefractory(v) {\n  refractory = 0.8 * v * v;\n}\n*/\n\n// Master CA Initializer\n// init the array to a random(ish) state appropriate for the\n// current mode.\nfunction seedCA() {\n  if (mode) {\n    seedCCA()\n  } else { \n    seedGH(excited,refractory);\n  }\n}\n\n// init classic CCA\n// Set all cells to random activation level \nfunction seedCCA() {\n  var x,y,i;\n  \n  lastState = buffer1;\n  currentState = buffer2;\n  \n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      currentState[x][y] = floor(random(numStates));\n      lastState[x][y] = currentState[x][y];      \n    }\n  }\n}\n\n// Init Greenberg-Hastings CA\n// Set cells given probability of excited and refactory levels. \n// TODO - rework this to shuffle instead of generating random coord pairs.\nfunction seedGH(probX,probR) {\n  var x,y,i;\n  \n  pb1 = buffer1;\n  pb2 = buffer2;\n  \n// zero arrays\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      pb1[x][y] = 0;\n      pb2[x][y] = 0;\n    }\n  }\n  \n// distribute excited cells  \n  probX = floor(pixelCount * probX)\n  for (i = 0; i < probX;) {\n    x = random(width); y = random(height);\n    if (pb2[x][y] == 0) {\n      pb2[x][y] = 1\n      i++;\n    }\n  }\n  \n// distribute refactory cells\n  probR = floor(pixelCount * probR)\n  for (i = 0; i < probR;) {\n    x = random(width); y = random(height)\n    if (pb2[x][y] == 0) {\n      pb2[x][y] =  2+floor(random(numStates - 2))\n      i++;\n    }\n  }\n}\n\n// create 2 x 2D buffers for calculation\nfunction allocateFrameBuffers() {\n  for (var i = 0; i < height; i ++) {\n    buffer1[i] = array(width);\n    buffer2[i] = array(width);\n  }\n  pb1 = buffer1;\n  pb2 = buffer2;\n}\n\nfunction swapBuffers()  {\n  var tmp = pb1; pb1 = pb2; pb2 = tmp;  \n}\n\n// counts excited neighbors\nfunction sumNeighborhood4(x,y,buffer) {\n  return (buffer[x][ym] == nextVal) + (buffer[x][yp] == nextVal) + \n    (buffer[xm][y] == nextVal) + (buffer[xp][y] == nextVal); \n}\n\nfunction sumNeighborhood8(x,y,buffer) {\n  return (buffer[x][ym] == nextVal) + (buffer[x][yp] == nextVal) + (buffer[xm][y] == nextVal) + \n         (buffer[xp][y] == nextVal) + (buffer[xm][ym] == nextVal) + (buffer[xp][ym] == nextVal) +\n         (buffer[xm][yp] == nextVal) + (buffer[xp][yp] == nextVal);\n}\n\nvar xm,xp,ym,yp;\nfunction doGenerationGH() {\n  swapBuffers();  \n  nextVal = 1;\n\n  for (var y = 0; y < height; y++) {\n    yp = (y + 1) % height;      \n    ym = (y > 0) ? y - 1 : height - 1;\n    \n    for (var x = 0; x < width; x++) {\n      xm = (x > 0) ? x - 1: width - 1;\n      xp = (x + 1) % width;      \n      \n      if (pb1[x][y] == 0) {\n        pb2[x][y] = (sumNeighborhood4(x,y,pb1) >= threshold);        \n      }\n      else {\n        pb2[x][y] = (pb1[x][y] + 1) % numStates;\n      }\n      sum += pb2[x][y];\n    }\n  }\n}\n\nfunction doGenerationCCA() {\n  swapBuffers();  \n\n  for (var y = 0; y < height; y++) {\n    yp = (y + 1) % height;      \n    ym = (y > 0) ? y - 1 : height - 1;\n    \n    for (var x = 0; x < width; x++) {\n      xm = (x > 0) ? x - 1: width - 1;\n      xp = (x + 1) % width;   \n      \n      nextVal = (pb1[x][y] + 1) % numStates;\n      var s = sumNeighborhood8(x,y,pb1);  \n      pb2[x][y] = (s >= threshold) ? nextVal : pb1[x][y]; \n      sum += (pb2[x][y] != pb1[x][y])\n    }\n  }\n}\n\n// Initialization\nallocateFrameBuffers();\n\nexport function beforeRender(delta) {\n  frameTimer += delta;\n  patternTimer += delta;\n\n// if the pattern hasn't died, and it's time for a new pattern,\n// reinitialize the array.\n  if ((sum == 0) || (lifetime && (patternTimer > lifetime))) {\n    seedCA(excited,refractory);\n    patternTimer = 0;\n  }\n\n  if (frameTimer > speed) {\n    sum = 0;    \n    calcNextGen();  \n    frameTimer = 0;\n  }\n}\n\n// The \"sum\" variable simply lets us know if any pixels have changed since the last\n// frame.  If not, the CA has died, and we need to start a new one, which we'll\n// do the next time beforeRender() is called.\nvar sum = 0;\nexport function render2D(index, x, y) {\n  x = (x * width);  \n  y = (y * height);\n  var cell = pb2[x][y];\n  var state = cell / numStates;\n  hsv(state,1, wave(state));\n}"
  },
  "preview": "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"
}