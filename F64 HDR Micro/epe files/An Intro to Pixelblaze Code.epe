{
  "name": "An Intro to Pixelblaze Code",
  "id": "vkpGsR88dcJmXfevp",
  "sources": {
    "main": "/*\n  Welcome to Pixelblaze!\n\n  Let's get you started with the Pixelblaze language. If you're an experienced \n  developer, you can skip to the concise language reference at the bottom of \n  this Edit page.\n  \n  First, we'll want to make sure your LEDs are connected and configured\n  correctly. When you load this tutorial pattern, there should be a test pattern\n  running that chases a red pixel, then a green pixel, then a blue pixel through\n  all your LEDs.\n\n  If that's not working, you'll want to double check your wiring and think\n  through each setting on the Settings tab.\n  \n  Have a look at the Getting Started page:\n  https://www.bhencke.com/pixelblaze\n  \n  Another resource is the forums:\n  https://forum.electromage.com/\n  \n  So, assuming your LEDs are all running, let's start learning the language.\n  Pixelblaze runs a simplified version of JavaScript. In the editor, free-form\n  text like this is called \"comments\" and are highlighted in brown. Code is in\n  white and some other colors. We can disable any code by turning it into\n  a comment. There are two ways:\n  \n  // Any single line can be a comment if it begins with two leading slashes\n  \n  Or an entire multi-line section (like this) can be a comment if you start\n  with slash-star and end with star-slash:\n*/\n\nvar ohHeyLookThisIsSomeCode\n\n/*\n  Practice commenting out some code. Here is the test pattern. You don't need \n  to understand it yet, but try surrounding it with slash-star, star-slash. \n  Or, play with disabling some of its lines by inserting a '//' on the left.\n*/\n\nexport function render(index) {\n  red = green = blue = 0\n  leadPosition = time(0.08) * pixelCount\n  red   = abs(leadPosition - index - 0) < 1\n  green = abs(leadPosition - index - 4) < 1\n  blue  = abs(leadPosition - index - 8) < 1\n  rgb(red, green, blue)\n}\n\n/*\n  Great! From here on out, we're going to keep learning by commenting out\n  entire examples and 'uncommenting' the next example. \n\n  This code editor is called ACE and it has some useful shortcuts you can find\n  here: https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts\n  One is that you can select multiple lines and comment or uncomment\n  them all at once with \"Ctrl-/\" (Win) or \"Cmnd-/\" (Mac). \n  \n  Try uncommenting the entire next example.\n*/\n\n// export function render(index) {\n//   purple = 0.8\n//   hsv(purple, 1, 0.2)\n// }\n\n/*\n  If that worked, all your LEDs should now be a light purple color. Select that\n  block of code and re-comment it out so it doesn't interfere with the next\n  examples.\n  \n  There are two basic concepts common to all Pixelblaze patterns:\n    1. The function named render()\n    2. Setting a pixel's color with hsv() or rgb()\n\n  Every pattern in Pixelblaze needs to have an exported function named \n  `render`. `render(index)` will be run once for every pixel, and the pixel's\n  index (its position in line) will be passed in as \"index\". The first LED in\n  the strip has an index of zero, the second LED is index 1, and so on. \n\n  In code jargon, we say render takes one \"argument\". It's convention for that\n  argument to be named \"index\". Render is \"called\" once per pixel, per frame.\n  It is \"passed\" the pixel index number as the argument.\n  \n  The word `export` is put before any functions or variables that some code\n  outside of your pattern will need to access. In this case, the overall\n  Pixelblaze system code needs to be able to run your render() function\n  and pass in all the pixels' indices.\n  \n  If we want to turn a pixel on, we need to have a line that sets its color.\n  That can be either:\n  \n    rgb(red, green, blue)\n    \n  or \n  \n    hsv(hue, saturation, value).\n    \n  Let's try turning on the third pixel and we'll make it green.\n*/\n\n// export function render(index) {\n//   if (index == 2) {  // index 2 is the third pixel\n//     rgb(0, 1, 0)     // Red is zero (off), green is 1 (full on), blue is 0\n//   } else {\n//     rgb(0, 0, 0)     // If the index is NOT equal to 2, all 3 colors are off\n//   }\n// }\n\n/*\n  That's actually quite verbose. If you're new to code, there's a few concepts \n  in there. First, the `if` and `else` statements let us do one thing or \n  another depending on whether the LED's index is 2, and note the use of\n  curly braces to group together all the lines that should be run. Second, \n  notice the double equal sign. This is a common gotcha for beginners. You'll\n  probably make this mistake sometime. If we're *testing* the value of\n  something, we use a double equals: `==`. A double equals means, \"is equal\n  to\". Contrast that to the code examples above where we *set* the value of a\n  variable with a single equal sign, such as `purple = 0.8`. A single equal sign\n  means, \"set the thing on the left equal to\".\n\n  Here's something more concise that does the exact same thing, but makes \n  the third pixel red instead of green:\n*/\n\n// export function render(index) {\n//   rgb(index == 2, 0, 0)    // Red is full on (1) when index is 2.\n// }\n\n/*\n  We'll skip over some programming concepts for now like how true is cast to a\n  1, and the only data type in Pixelblaze is 16.16 fixed point numbers.\n  \n  If we want to get learning by example, it's time to start going a little \n  faster to make our animated rainbow dreams into reality. Let's talk color.\n  \n  An artist doesn't typically think, \"I'm envisioning a beautiful red-green in \n  the additive color model,\" they think, \"I want it to be yellow.\"\n*/\n\n// export function render(index) {\n//   rgb(0.5, 0.3, 0)    // Hey look it's red-green, and no blue! Err.. yellow.\n// }\n\n/*\n  What we'd prefer is something where we could specify a color with a single\n  number. That way, we could animate that number and traverse through a\n  rainbow. This exists - there's an alternate representation of RGB color space\n  known as HSV. In this model, hue is a continuous \"wheel\" of colors.\n  \n  You'll find that most people prefer to use hsv() over rgb() for this reason. \n  Another advantage is that using hsv() will do special things to render colors\n  in HDR on the more advanced SK9822/APA102 LEDs.\n  \n  Let's break apart `hsv(hue, saturation, value)`:\n  \n    hue: A number from 0-1 that is the essential spectrum name of the color.\n      0.0  = Red\n      0.02 = Orange\n      0.1  = Yellow\n      0.33 = Green\n      0.45 = Mint\n      0.5  = Cyan\n      0.66 = Blue\n      0.9  = Violet\n    \n    saturation: How saturated, or pure, the color is.\n      1   = Just that color\n      0.5 = Some white mixed in with this color\n      0   = All white, no matter what the hue is set to\n    \n    value: The overall brightness of the color.\n      0 = Off\n      1 = Full brightness\n    \n    Go ahead and play with all three.\n*/\n\n// export function render(index) {\n//   hsv(0.5, 1, 0.2)\n// }\n\n/*\n  Now that you understand how hsv() works, if we add the random() function, you\n  can now understand how the \"firework dust\" pattern works.\n*/\n\n// export function render(index) {\n//   v = random(1000) < 5 // v is \"true\" (1) about 5-in-1000 times \n//   // A pixel will be a random hue, and it's only on 5-in-1000 times\n//   hsv(random(1), 1, v)\n// }\n\n/*\n  Let's save you hours of experimenting by noting a few things up front if\n  you're new to RGB LEDs and the HSV color space.\n\n  Hue isn't uniformly spread across a rainbow. Notice how close orange (0.02)\n  is to red (0)?\n\n  Saturation is fairly sensitive and depends on the hue we are trying to \n  desaturate. While 1 = pure color, a saturation of 0.9 actually mixes in quite\n  a bit of white.\n  \n  Value (v) is the amount of light energy. You might think that a `v` value of\n  0.5 should be half of the maximum brightness when v = 1, but humans actually \n  perceive brightness on a power-law scale (search for \"gamma correction\" for\n  more information). This means that our eyes perceive v = 0.25 as about half \n  as bright as v = 1. This is why you'll see a lot of example patterns that do \n  something like this:\n  \n  v = v * v  // or even v = v * v * v\n  \n  Recall that squaring or cubing a number in 0...1 makes it smaller. As a\n  side note, you'll find that a lot of Pixelblaze involves math on values from\n  zero to one. A lot of people eventually find this to be very convenient.\n\n  To explore the perception of brightness as it relates to v, let's write a \n  pattern that makes each pixel half the v of the one before it, and see if \n  each pixel looks half as bright.\n\n  If you find that only a few pixels are lit, you might want to raise your\n  global brightness level. See the slider in the header, or check your global\n  brightness limit in the Settings tab.\n*/\n\n// export function render(index) {\n//   v = 1 / pow(2, index) // 1, 0.5, 0.25, 0.125, etc\n//   // Try uncommenting the following v = v * v.\n//   // It ends up looking more like \"half\" the prior pixel's brightness.\n//   // v = v * v  \n//   hsv(0, 0, v) // White, because saturation = 0\n// }\n\n/*\n  Let's try another way. Let's say we wanted to fade the brightness across\n  our whole strip. We want to see which fade-out is the most natural looking.\n\n  This is a good time to introduce a special variable in Pixelblaze that's \n  always available and will be very useful. `pixelCount` will always be set to\n  the total number of pixels configured in the Settings tab. Since a lot of\n  functions in Pixelblaze take numbers in the 0..1 range, you'll see\n  a lot of stuff like this:\n  \n    index / pixelCount  // Returns 0..1 across all LEDs\n*/\n\n// export function render(index) {\n//   v = index / pixelCount\n//   // Try uncommenting one of the following\n//   // Also play with the global brightness slider to see the effect\n//   // v = v * v\n//   // v = pow(v, 2.5)\n//   // v = 0.005 + v * v * v\n//   hsv(2/3, 1, v) // Just the blue LED\n// }\n\n/* \n  I'm a little worried you're getting bored so here's something exciting. This\n  is a pattern in the default library called \"Block reflections\".\n*/\n\n// export function render(index) {\n//   t1 = time(0.1)\n//   m = .3 + triangle(t1) * .2\n//   n = triangle(time(0.5)) * 10 + 4 * sin(time(0.2) * PI2)\n//   h = sin(t1*PI2) + (((index - pixelCount / 2) / pixelCount * n % m))\n//   v = (abs(h) + abs(m) + t1) % 1\n//   hsv(h, 1, v * v)\n// }\n\n/*\n  Pretty, right? You may not understand the math (I'm not sure I do!), but the \n  important part is you can now recognize render(), index, pixelCount, hsv(),  \n  v * v, and variables being set!\n  \n  Something that is initially frustrating about coding but eventually becomes\n  easier is finding unbalanced brackets: {} () []\n  \n  See if you can uncomment and then repair the code below. Look for the red\n  error message below the editor. Unbalanced brackets usually result in errors\n  like \"Unexpected token\" or \"Unexpected identifier\". The solution is in the\n  next comment block.\n*/\n\n// export function render(index) {\n//   x = (wave(time(0.05) + index / pixelCount) / 2\n//   v = wave(7 * x) * wave(11 * x)\n//   if (x > index / pixelCount) {\n//     offset = 0.5\n//   else {\n//     offset = 0\n//   }\n//   hsv(offset + x/4, 1, v * v)\n// }\n\n/*\n  Answer: It was missing a \")\" after \"time(0.05)\" to close the \"wave(\", and the\n  line \"else {\" needs to be \"} else {\" to close the \"if (condition) {\".\n  \n  OK, let's move on to another special function you'll see in many patterns.\n  beforeRender() is called between frames. beforeRender() takes an argument \n  we usually name \"delta\" which is how much time has passed (in milliseconds) \n  since the last time beforeRender() was called. In other words, how much time\n  does it take to calculate all the pixels once?\n  \n  Let's say you have 4 pixels and it takes 10ms to compute all 4 of them. This \n  is what Pixelblaze does each time you run (or even edit!) your pattern:\n  \n    Interprets (runs) all of the pattern's code\n    calls beforeRender()\n    calls render(0)\n          render(1)\n          render(2)\n          render(3) - This frame of 4 pixels is now complete and displayed\n    calls beforeRender(10), because 10ms elapsed since the first beforeRender()\n    calls render(0)\n          ... etc\n    \n  beforeRender() is therefore a useful and efficient place to do a bunch of \n  things: Check timers, read sensors, calculate motion, or pre-compute an entire \n  frame, which is called frame buffering.\n  \n  We can set variables in beforeRender() that are accessible in render(). These\n  are called global variables because they can be read and set in any function.\n  \n  Here's a very common use for beforeRender(). We're going to compute what \n  \"time\" it is for this frame. Instead of knowing the exact number of seconds\n  of milliseconds elapsed, it's common practice to set up a global timer \n  variable that loops from 0 to 1 at a certain speed. That's what the time() \n  helper function does.\n\n  You can think of this as being like a rotary stopwatch, but you get to set\n  how long it takes to complete one revolution. \n  \n  Let's try visualizing a 4 second timer in a variable called t1.\n*/\n\n// export function beforeRender(delta) {\n//   t1 = time(4 / 65.536) // From 0..1 every 4 seconds\n// }\n// export function render(index) {\n//   // Which pixel should we turn on? As t1 goes from 0..1, onPixel will be the\n//   // integer from zero to the total number of pixels we've configured.\n//   onPixel = floor(t1 * pixelCount) \n//\n//   v = 0 // Start by assuming the pixel is off\n//   // Turn it on only if the current pixel's index is equal to `onPixel`\n//   if (index == onPixel) v = 1\n//   hsv(0.02, 1, v)\n// }\n\n/*\n  Want a challenge? See if you can modify that pattern to change the color\n  of the pixel as it moves.\n  \n  It's nice that one pixel is on, but how can we make the animation smoother,\n  so that it's more like a pulse with a halo? Let's set the brightness based\n  on how far the pixel is from our traveling pulse. We'll also use the\n  clamp() function, which limits a value to be within a certain range.\n*/\n\n// export function beforeRender(delta) {\n//   t1 = time(4 / 65.536) // From 0..1 every 4 seconds\n// }\n\n// export function render(index) {\n//   pulsePosition = t1 * pixelCount // In units of pixels\n//   distanceFromPulse = abs(pulsePosition - index) // Still in pixels\n//   // We need something that's high when we're close to the pulse, \n//   // and low or negative when we're far from the t1 pulse position.\n//   halfWidth = 5 // pixels\n//   // When proximityToPulse == 5, we're at the pulse, 1 is dim, >= 0 is off\n//   proximityToPulse = halfWidth - distanceFromPulse \n//   pctCloseToPulse = proximityToPulse / halfWidth // Now from 1 to 0 \n//   v = clamp(pctCloseToPulse, 0, 1)\n\n//   // Or, much more succinctly\n//   // v = max(0, 1 - abs(t1 * pixelCount - index) / 5)\n\n//   // Or a third way: 10% of strip width, not 5 pixels\n//   // v = triangle(clamp((index/pixelCount - t1) / 0.2 + 0.5, 0, 1))\n//   hsv(0.02, 1, v * v)\n// }\n\n/*\n  If that pattern made you think, \"Oooooh I wonder if I could make a fire-like\n  pattern,\" then congrats you'll fit right in here.\n  \n  If that pattern made you think, \"Uh.. that's a lot of math I don't remember,\"\n  don't worry! You'll fit right in here too!\n  \n  Another technique you'll sometimes see in Pixelblaze code is counting time (by\n  adding up deltas) to do something every X seconds. Let's make a pattern that\n  has two modes, mode 0 and mode 1. Mode 0 is just all off, and mode one is all\n  red. So it's kind of an overcomplicated blinker. How can we switch modes once\n  per second? We'll keep adding up the deltas and switch modes after we've \n  counted out 1000ms (1 second).\n*/\n\n// elapsedMs = 0\n// mode = 0\n// export function beforeRender(delta) {\n//   elapsedMs = elapsedMs + delta\n//   if (elapsedMs > 1000) {\n//     elapsedMs = 0 // A second has passed, so reset our accumulator\n//     mode = 1 - mode\n//   }\n// }\n// export function render(index) {\n//   if (mode == 0) { \n//     hsv(0, 0, 0) \n//   } else { \n//     hsv(0, 1, 0.1)\n//   }\n// }\n\n/*\n  If you're coming from Arduino, you might think this is quite involved compared\n  to the simplicity of:\n  \n    void loop() { delay(1000); toggleLED(); }\n  \n  Writing non-blocking code is just a different set of techniques. You'll pick\n  it up, don't worry.\n  \n  There's usually several ways to do something, and the method above was\n  written quite verbosely. Here's another way to do the same thing.\n*/\n\n// elapsedMs = 0\n// export function beforeRender(delta) {\n//   elapsedMs += delta   // Same as elapsedMs = elapsedMs + delta\n//   if (elapsedMs > 2000) elapsedMs -= 2000\n// }\n// export function render(index) {\n//   hsv(0, 1, 0.1 * (elapsedMs < 1000))\n// }\n\n/*\n  That's a more compact way to do *something* every 2 seconds, but if all we\n  needed to do was blink there's even simpler ways!\n*/\n\n// export function render(index) {\n//   hsv(0, 1, time(0.03) > 0.5)\n// }\n\n/*\n  But if we want to cycle through many modes in a single pattern, accumulating \n  deltas is a decent way. Check out the \"Example: ...\" built-in patterns to see \n  this in use.\n\n  Remember how we mentioned that you can use beforeRender() to pre-compute (or\n  \"buffer\") an entire frame? There are several examples that ship with \n  Pixelblaze showing this technique. First, see the \"KITT\" pattern, which \n  includes a video tutorial:\n  \n  \"Writing a Knight Rider KITT LED Pattern with Pixelblaze\" \n  https://www.youtube.com/watch?v=3ugNIZ96UK4\n  \n  Also check out the \"sparks\" and \"blink fade\" patterns to see buffering in \n  action.\n  \n  At this point you're ready to start checking out the other example patterns \n  and diving into the docs below the editor on this page.\n  \n  If you've got a specific coding challenge, there's usually someone ready to\n  help you on the forums: https://forum.electromage.com/\n  \n  Good luck!\n*/\n"
  },
  "preview": "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"
}